// ***************************
// Date:
// Author:
// Module Name: StateMachine
// Description:
// ***************************
#include "verilated.h"
#include <verilated_vcd_c.h>
// Included with project
#include "include/Testbench.hpp"
//Generated by verilator
#include "VStateMachine.h"
// Generated by python script
#include "include/port.hpp"
// Std library
#include <iostream>
#include <string>


template<typename T, typename U>
void print(T val1, U val2) {
    std::cout << val1 << " : " << val2 << std::endl;
}

template<typename T, typename U, typename V>
void print(T val1, U val2, V val3) {
    std::cout << val1 << " : " << val2 << " : " << val3 << std::endl;
}


enum opcode {
    LB    = 0b100000,
    SB    = 0b101000,
    RTYPE = 0b000000,
    BEQ   = 0b000100,
    J     = 0b000010

};

enum state {
    S_FETCH = 0,
    S_DECODE,
    S_MEMADR,
    S_LBRD,
    S_LBWR,
    S_SBWR,
    S_RTYPEEX,
    S_RTYPEWR,
    S_BEQEX,
    S_JEX
};

std::string toBinary(int num, int bits) {
    std::string binary = "0b";
    for (int i = bits-1; i >= 0; i--) {
        binary += ((num >> i) & 0b1) ? "1": "0";
    }
    return binary;
}

std::string getState(int state, OUTPUT_PORT *port) {
    switch(state) {
        case 0 :
            port->o_alusrcb = 0b01;
            port->o_pcwrite = 0b1;
            break;
        case 1 :
            port->o_alusrcb = 0b11;
            return "DECODE";
        case 2 :
            port->o_alusrca = 0b1;
            port->o_alusrcb = 0b10;
            return "MEMADR";
        case 3 :
            port->o_iord = 0b1;
            return "LBRD";
        case 4 :
            port->o_regwrite = 0b1;
            port->o_memtoreg = 0b1;
            return "LBWR";
        case 5 :
            port->o_iord = 0b1;
            port->o_memwrite = 0b1;
            return "SBWR";
        case 6 :
            port->o_alusrca = 0b1;
            port->o_aluop = 0b10;
            return "RTYPEEX";
        case 7 :
            port->o_regwrite = 0b1;
            port->o_regdst = 0b1;
            return "RTYPEWR";
        case 8 :
            port->o_alusrca = 0b1;
            port->o_aluop = 0b01;
            port->o_branch = 0b1;
            port->o_pcsrc = 0b01;
            return "BEQEX";
        case 9 :
            port->o_pcwrite = 0b1;
            port->o_pcsrc = 0b10;
            return "JEX";
    }
    return "FETCH";
}


void loadOpCode(opcode op, std::string name, Testbench *top) {
    top->m_core->i_op = op;
    print("Opcode", name);
    print("\tState", getState(top->m_core->v__DOT__state, top->testPort), toBinary(top->m_core->v__DOT__state, 4));
    top->runTests();
    top->tick();
    while ( top->m_core->v__DOT__state != S_FETCH ) {
        print("\tState", getState(top->m_core->v__DOT__state, top->testPort), toBinary(top->m_core->v__DOT__state, 4));
        top->runTests();
        top->tick();
    }
}


int main(int argc, char **argv, char **env) {
    Verilated::commandArgs(argc, argv);
    Testbench *top = new Testbench();


    // Open the trace file for waveform vcd
    print("C++ Version", __cplusplus);
    print("Int ", sizeof(uint32_t));
    print("Uint ", sizeof(unsigned int));
    print("Out Port: ", sizeof(top->testPort));
    print("Out Port: ", sizeof(top->m_core->o_alusrcb));
    top->opentrace("trace/trace.vcd");
    top->reset();


    loadOpCode(LB, "LB", top);
    loadOpCode(SB, "SB", top);
    loadOpCode(RTYPE, "RTYPE", top);
    loadOpCode(BEQ, "BEQ", top);
    loadOpCode(J, "J", top);


    delete top;
    exit(0);
}

