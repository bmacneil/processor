// Date:
// ***************************
// Author:
// Module Name: Controller
// Description:
// ***************************
#include "verilated.h"
#include <verilated_vcd_c.h>
// Included with project
#include "include/Testbench.hpp"
//Generated by verilator
#include "VController.h"
// Generated by python script
#include "include/port.hpp"
// Std library
#include <iostream>
#include <string>
#include <list>

using std::list;
using std::string;

template<typename T, typename U>
void print(T val1, U val2) {
    std::cout << val1 << " : " << val2 << std::endl;
}

template<typename T, typename U, typename V>
void print(T val1, U val2, V val3) {
    std::cout << val1 << " : " << val2 << " : " << val3 << std::endl;
}

enum opcode {LB    = 0b100000,
             SB    = 0b101000,
             RTYPE = 0b000000,
             BEQ   = 0b000100,
             J     = 0b000010};

enum functcode {ADD = 0b100000,
                SUB = 0b100010,
                AND = 0b100100,
                OR  = 0b100101,
                SLT = 0b101010,
                NON = 0b000000};

string get_opcode_str(int op) {
    switch(op) {
        case LB:
            return "LB";
        case SB:
            return "SB";
        case RTYPE:
            return "RTYPE";
        case BEQ:
            return "BEQ";
        case J:
            return "J";
    }
    return "ERROR: Invalid Function Code";
}

string get_funct_str(int funct) {
    switch(funct) {
        case ADD:
            return "ADD";
        case SUB:
            return "SUB";
        case AND:
            return "AND";
        case OR:
            return "OR";
        case SLT:
            return "SLT";
        case NON:
            return "NONE";
    }
    return "ERROR: Invalid Op Code";
}

enum state {
    S_FETCH = 0,
    S_DECODE,
    S_MEMADR,
    S_LBRD,
    S_LBWR,
    S_SBWR,
    S_RTYPEEX,
    S_RTYPEWR,
    S_BEQEX,
    S_JEX
};

string getState(int state, OUTPUT_PORT *port) {
    switch(state) {
        case S_FETCH:
            port->o_alusrcb = 0b01;
            port->o_pcen = 0b1;
            break;
        case S_DECODE:
            port->o_alusrcb = 0b11;
            return "DECODE";
        case S_MEMADR:
            port->o_alusrca = 0b1;
            port->o_alusrcb = 0b10;
            return "MEMADR";
        case S_LBRD:
            port->o_iord = 0b1;
            return "LBRD";
        case S_LBWR:
            port->o_regwrite = 0b1;
            port->o_memtoreg = 0b1;
            return "LBWR";
        case S_SBWR:
            port->o_iord = 0b1;
            port->o_memwrite = 0b1;
            return "SBWR";
        case S_RTYPEEX:
            port->o_alusrca = 0b1;
            // port->o_aluop = 0b10;
            return "RTYPEEX";
        case S_RTYPEWR:
            port->o_regwrite = 0b1;
            port->o_regdst = 0b1;
            return "RTYPEWR";
        case S_BEQEX:
            port->o_alusrca = 0b1;
            // port->o_aluop = 0b01;
            // port->o_branch = 0b1;
            port->o_pcsrc = 0b01;
            return "BEQEX";
        case S_JEX:
            port->o_pcen = 0b1;
            port->o_pcsrc = 0b10;
            return "JEX";
    }
    return "FETCH";
}

uint16_t get_instr(opcode op, functcode funct) {
    return (op << 6) | funct;
}

list<uint16_t> instr = {
    get_instr(LB, NON),
    get_instr(SB, NON),
    get_instr(BEQ, NON),
    get_instr(J, NON),
    get_instr(RTYPE, ADD),
    get_instr(RTYPE, SUB),
    get_instr(RTYPE, AND),
    get_instr(RTYPE, OR),
    get_instr(RTYPE, SLT),
};


bool next_instr(VController *core){
    if(core->o_pcen == 0b1 && core->o_alusrcb == 0b01)
        return true;
    else
        return false;
}

void load_instr(VController *core, list<uint16_t> &instr_list) {
    if (!instr_list.empty()) {
        uint16_t instr = instr_list.front();
        instr_list.pop_front();
        core->i_op = (instr >> 6) & 0x3F; // get the upper 6 bits
        core->i_funct = instr & 0x3F; //Return lower 6 bits
    }
}

int main(int argc, char **argv, char **env) {
    Verilated::commandArgs(argc, argv);
    Testbench *top = new Testbench();
    // Open the trace file for waveform vcd
    top->opentrace("trace/trace.vcd");
    top->reset();
    load_instr(top->m_core, instr);
    bool done = false;
    while (!done) {  // !top->done()
        top->tick();
        if (next_instr(top->m_core)) {
            load_instr(top->m_core, instr);
            print(get_opcode_str(top->m_core->i_op), get_funct_str(top->m_core->i_funct));
        }
        if (instr.empty()) done = true;

    }
    delete top;
    exit(0);
}
