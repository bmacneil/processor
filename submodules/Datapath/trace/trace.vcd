$version Generated by VerilatedVcd $end
$date Tue Apr  3 13:17:59 2018
 $end
$timescale 1ns $end

 $scope module TOP $end
  $var wire  1 F i_AluSrcA $end
  $var wire  2 H i_AluSrcB [1:0] $end
  $var wire  1 E i_IorD $end
  $var wire 32 M i_Memdata [31:0] $end
  $var wire  1 D i_PCen $end
  $var wire  2 G i_PCsrc [1:0] $end
  $var wire  3 I i_alucontrol [2:0] $end
  $var wire  1 > i_clk $end
  $var wire  1 C i_instrwrite $end
  $var wire  1 A i_memtoreg $end
  $var wire  1 B i_regdst $end
  $var wire  1 @ i_regwrite $end
  $var wire  1 ? i_reset $end
  $var wire 32 N o_Address [31:0] $end
  $var wire  6 K o_funct [5:0] $end
  $var wire  6 J o_op [5:0] $end
  $var wire  1 L o_zero $end
  $scope module v $end
   $var wire 32 : ALUout [31:0] $end
   $var wire 32 0 ALUresult [31:0] $end
   $var wire 32 . AluA [31:0] $end
   $var wire 32 / AluB [31:0] $end
   $var wire 32 # Imm [31:0] $end
   $var wire 32 ; PC [31:0] $end
   $var wire 32 8 RegA [31:0] $end
   $var wire  5 6 RegA_addr [4:0] $end
   $var wire 32 9 RegB [31:0] $end
   $var wire  5 7 RegB_addr [4:0] $end
   $var wire  5 - RegD_addr [4:0] $end
   $var wire 32 O WIDTH [31:0] $end
   $var wire  1 F i_AluSrcA $end
   $var wire  2 H i_AluSrcB [1:0] $end
   $var wire  1 E i_IorD $end
   $var wire 32 M i_Memdata [31:0] $end
   $var wire  1 D i_PCen $end
   $var wire  2 G i_PCsrc [1:0] $end
   $var wire  3 I i_alucontrol [2:0] $end
   $var wire  1 > i_clk $end
   $var wire  1 C i_instrwrite $end
   $var wire  1 A i_memtoreg $end
   $var wire  1 B i_regdst $end
   $var wire  1 @ i_regwrite $end
   $var wire  1 ? i_reset $end
   $var wire 32 N o_Address [31:0] $end
   $var wire  6 K o_funct [5:0] $end
   $var wire  6 J o_op [5:0] $end
   $var wire  1 L o_zero $end
   $scope module alu $end
    $var wire 32 O WIDTH [31:0] $end
    $var wire 32 2 andresult [31:0] $end
    $var wire 32 1 b2 [31:0] $end
    $var wire 32 . i_a [31:0] $end
    $var wire  3 I i_alucontrol [2:0] $end
    $var wire 32 / i_b [31:0] $end
    $var wire 32 0 o_result [31:0] $end
    $var wire  1 L o_zero $end
    $var wire 32 3 orresult [31:0] $end
    $var wire 32 5 sltresult [31:0] $end
    $var wire 32 4 sumresult [31:0] $end
   $upscope $end
   $scope module alu_mux $end
    $var wire 32 O WIDTH [31:0] $end
    $var wire  1 F i_AluSrcA $end
    $var wire  2 H i_AluSrcB [1:0] $end
    $var wire 32 # i_Imm [31:0] $end
    $var wire 32 ; i_PC [31:0] $end
    $var wire 32 8 i_RegA [31:0] $end
    $var wire 32 9 i_RegB [31:0] $end
    $var wire 32 , imm_shift [31:0] $end
    $var wire 32 . o_AluA [31:0] $end
    $var wire 32 / o_AluB [31:0] $end
   $upscope $end
   $scope module instr_decoder $end
    $var wire 32 O WIDTH [31:0] $end
    $var wire 32 M i_Memdata [31:0] $end
    $var wire  1 > i_clk $end
    $var wire  1 C i_instrwrite $end
    $var wire  1 B i_regdst $end
    $var wire  1 ? i_reset $end
    $var wire 32 = instruction [31:0] $end
    $var wire  8 < o_Imm [7:0] $end
    $var wire  5 6 o_RegA_addr [4:0] $end
    $var wire  5 7 o_RegB_addr [4:0] $end
    $var wire  5 - o_RegD_addr [4:0] $end
    $var wire  6 K o_funct [5:0] $end
    $var wire  6 J o_op [5:0] $end
   $upscope $end
   $scope module pc_decoder $end
    $var wire 32 : ALU_sig [31:0] $end
    $var wire 32 O WIDTH [31:0] $end
    $var wire 32 0 i_ALUresult [31:0] $end
    $var wire 32 # i_Imm [31:0] $end
    $var wire  1 E i_IorD $end
    $var wire  1 D i_PCen $end
    $var wire  2 G i_PCsrc [1:0] $end
    $var wire  1 > i_clk $end
    $var wire  1 ? i_reset $end
    $var wire 32 : o_ALUout [31:0] $end
    $var wire 32 N o_Address [31:0] $end
    $var wire 32 ; o_PC [31:0] $end
   $upscope $end
   $scope module registers $end
    $var wire 32 $ RegTable(0) [31:0] $end
    $var wire 32 % RegTable(1) [31:0] $end
    $var wire 32 & RegTable(2) [31:0] $end
    $var wire 32 ' RegTable(3) [31:0] $end
    $var wire 32 ( RegTable(4) [31:0] $end
    $var wire 32 ) RegTable(5) [31:0] $end
    $var wire 32 * RegTable(6) [31:0] $end
    $var wire 32 + RegTable(7) [31:0] $end
    $var wire 32 O WIDTH [31:0] $end
    $var wire 32 : i_ALUout [31:0] $end
    $var wire 32 M i_Memdata [31:0] $end
    $var wire  5 6 i_RegA_addr [4:0] $end
    $var wire  5 7 i_RegB_addr [4:0] $end
    $var wire  5 - i_RegD_addr [4:0] $end
    $var wire  1 > i_clk $end
    $var wire  1 A i_memtoreg $end
    $var wire  1 @ i_regwrite $end
    $var wire  1 ? i_reset $end
    $var wire 32 8 o_RegA [31:0] $end
    $var wire 32 9 o_RegB [31:0] $end
   $upscope $end
  $upscope $end
 $upscope $end
$enddefinitions $end


#8
b00000000000000000000000000000000 $
b00000000000000000000000000000000 %
b00000000000000000000000000000000 &
b00000000000000000000000000000000 '
b00000000000000000000000000000000 (
b00000000000000000000000000000000 )
b00000000000000000000000000000000 *
b00000000000000000000000000000000 +
b00000000000000000000000000000000 #
b00000000000000000000000000000000 ,
b00000 -
b00000000000000000000000000000000 0
b00000000000000000000000000000000 1
b00000000000000000000000000000000 2
b00000000000000000000000000000000 3
b00000000000000000000000000000000 4
b00000000000000000000000000000000 5
b00000000000000000000000000000000 .
b00000000000000000000000000000000 /
b00000 6
b00000 7
b00000000 <
b00000000000000000000000000000000 =
b00000000000000000000000000000000 :
b00000000000000000000000000000000 ;
b00000000000000000000000000000000 8
b00000000000000000000000000000000 9
0@
0A
0C
0B
b00000000000000000000000000000000 M
b000000 J
b000000 K
0>
1?
0D
0E
b00 G
b00000000000000000000000000000000 N
b000 I
1L
0F
b00 H
b00000000000000000000000000100000 O
#10
1>
#15
0>
#18
0?
#20
1>
#25
0>
#28
b00000000000000000000000000000001 0
b00000000000000000000000000000001 1
b00000000000000000000000000000001 3
b00000000000000000000000000000001 4
b00000000000000000000000000000001 /
1C
b00000000000000000000000000100000 M
1D
b010 I
0L
b01 H
#30
b00000000000000000000000000100000 #
b00000000000000000000001000000000 ,
b00000000000000000000000000000010 0
b00000000000000000000000000000001 2
b00000000000000000000000000000010 4
b00000000000000000000000000000001 .
b00100000 <
b00000000000000000000000000100000 =
b00000000000000000000000000000001 :
b00000000000000000000000000000001 ;
b100000 K
1>
b00000000000000000000000000000001 N
#35
0>
#38
b00000000000000000000000000000001 0
b11111111111111111111110111111111 1
b00000000000000000000000000000000 2
b00000000000000000000001000000001 3
b11111111111111111111111000000001 4
b00000000000000000000000000000001 5
b00000000000000000000001000000000 /
b111 I
b11 H
#40
1>
#45
0>
#48
b00000000000000000000001000000000 3
b11111111111111111111111000000000 4
b00000000000000000000000000000000 .
1F
#50
1>
#55
0>
#58
1@
1B
#60
b00000000000000000000000000000001 $
1>
#65
0>
