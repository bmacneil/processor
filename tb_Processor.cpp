// ***************************
// Date:
// Author:
// Module Name: Processor
// Description:
// ***************************
#include "verilated.h"
#include <verilated_vcd_c.h>
// Included with project
#include "include/Testbench.hpp"
//Generated by verilator
#include "VProcessor.h"
// Generated by python script
#include "include/port.hpp"
// Std library
#include <iostream>
#include <iomanip>
#include <string>

using std::string;
using std::cout;
using std::endl;

int count = 0;
bool quiet = false;
                                     //        OP      RA     RB     Imm
uint32_t MEMORY [256] = {0x80020011, // 0x00   LB      0x0    0x2    0x11
                         0x80070010, // 0x01   LB      0x0    0x7    0x10
                         0x80e3000f, // 0x02   LB      0x7    0x3    0x09
                         0x00e22025, // 0x03   RTYPE   0x7    0x2    0x4           OR
                         0x00642824, // 0x04   RTYPE   0x3    0x4    0x5           AND
                         0x00a42820, // 0x05   RTYPE   0x5    0x4    0x5           ADD
                         0x10a70008, // 0x06   BEQ     0x5    0x7    0x8
                         0x0064302a, // 0x07   RTYPE   0x3    0x4    0x6           SLT
                         0x10c00001, // 0x08   BEQ     0x6    0x0    0x1
                         0x80050000, // 0x09   LB      0x0    0x5    0x0
                         0x00e2302a, // 0x0A   RTYPE   0x7    0x2    0x6           SLT
                         0x00c53820, // 0x0B   RTYPE   0x6    0x5    0x7           ADD
                         0x00e23822, // 0x0C   RTYPE   0x7    0x2    0x7           SUB
                         0x0800000f, // 0x0D   J       0xf
                         0x80070000, // 0x0E   LB      0x0    0x7    0x0
                         0xa047000e, // 0x0F   SB      0x2    0x7    0x47
                         0x00000003, // 0x10   RTYPE   0x0    0x0    0x0           3
                         0x00000005, // 0x11   RTYPE   0x0    0x0    0x0           5
                         0x0000000c};// 0x12   RTYPE   0x0    0x0    0x0           12

template<typename T, typename U>
void print(T val1, U val2) {
    std::cout << val1 << " : " << val2 << std::endl;
}

template<typename T, typename U, typename V>
void print(T val1, U val2, V val3) {
    std::cout << val1 << " : " << val2 << " : " << val3 << std::endl;
}

// void assert_output(Testbench *top, int expected) {
//     top->testPort->o_out = expected;
// }

enum opcode {LB    = 0b100000,
             SB    = 0b101000,
             RTYPE = 0b000000,
             BEQ   = 0b000100,
             J     = 0b000010};

enum functcode {ADD = 0b100000,
                SUB = 0b100010,
                AND = 0b100100,
                OR  = 0b100101,
                SLT = 0b101010,
                NON = 0b000000};

string get_opcode_str(int op) {
    switch(op) {
        case LB:
            return "LB   " + to_string(op);
        case SB:
            return "SB   " + to_string(op);
        case RTYPE:
            return "RTYPE " + to_string(op);
        case BEQ:
            return "BEQ   " + to_string(op);
        case J:
            return "J     " + to_string(op);
    }
    return "ERROR: Invalid Op Code " + to_string(op);
}

string get_funct_str(int funct) {
    switch(funct) {
        case ADD:
            return "ADD";
        case SUB:
            return "SUB";
        case AND:
            return "AND";
        case OR:
            return "OR";
        case SLT:
            return "SLT";
        default:
            return "NONE";
    }
    return "ERROR: Invalid Function Code";
}

string decode_instr(int instr) {
    string op_str = get_opcode_str((instr >> 26) & 0x3F);
    string funct_str = get_funct_str(instr & 0x3F);
    return " op: [" + op_str + "] funct: [" + funct_str + "]";
}

uint32_t get_instruction(int address) {
    if(!quiet) {
        std::cout << "Addr: [0x" << hex << uppercase << std::setw(8)
        << std::setfill('0') << address << "]  Instr: [0x" << hex <<
        uppercase << std::setw(8) << std::setfill('0') << MEMORY[address]
        << "]" << decode_instr(MEMORY[address]) << std::endl;
    }
    return MEMORY[address];
}

void print_state(Testbench * top, int address) {
    if (!quiet) {
        cout << "Cycle: " << top->m_tickcount;
        cout<< " State: " << int(top->m_core->v__DOT__controller_0__DOT__fsm__DOT__state)
        << " Address: " << address <<endl;
    }
}

string assert_MEM_0x11_loaded_into_REG_0x2(Testbench * top, uint32_t * RegTable) {
// 0x80020011  LB      0x0    0x2    0x11
    uint32_t address = uint32_t(top->m_core->o_Address);
    uint32_t instr = get_instruction(address);
    top->m_core->i_ReadData = instr;
    print_state(top, address);
    top->tick();
    address = uint32_t(top->m_core->o_Address);
    instr = get_instruction(address);
    top->m_core->i_ReadData = instr;
    print_state(top, address);
    while(int(top->m_core->v__DOT__controller_0__DOT__fsm__DOT__state) != 0b0001) {
        top->tick();
        address = uint32_t(top->m_core->o_Address);
        instr = get_instruction(address);
        top->m_core->i_ReadData = instr;
        print_state(top, address);
    }
    top->testPort->o_Address = address;
    count++;
    assert(RegTable[2] == MEMORY[0x11]);
    return "assert_MEM_0x11_loaded_into_REG_0x2";
}

string assert_MEM_0x10_loaded_into_REG_0x7(Testbench * top, uint32_t * RegTable) {
// 0x80070010, // 0x01 LB      0x0    0x7    0x10
    uint32_t address = uint32_t(top->m_core->o_Address);
    uint32_t instr = get_instruction(address);
    top->m_core->i_ReadData = instr;
    print_state(top, address);
    top->tick();
    address = uint32_t(top->m_core->o_Address);
    instr = get_instruction(address);
    top->m_core->i_ReadData = instr;
    print_state(top, address);
    while(int(top->m_core->v__DOT__controller_0__DOT__fsm__DOT__state) != 0b0001) {
        top->tick();
        address = uint32_t(top->m_core->o_Address);
        instr = get_instruction(address);
        top->m_core->i_ReadData = instr;
        print_state(top, address);
    }
    top->testPort->o_Address = address;
    count++;
    assert(RegTable[7] == MEMORY[0x10]);
    return "assert_MEM_0x10_loaded_into_REG_0x7";
}

string assert_MEM_0x12_loaded_into_REG_0x3(Testbench * top, uint32_t * RegTable) {
    // 0x80e3000f 0x02   LB      0x7    0x3    0x0F
    uint32_t address = uint32_t(top->m_core->o_Address);
    uint32_t instr = get_instruction(address);
    top->m_core->i_ReadData = instr;
    print_state(top, address);
    top->tick();
    address = uint32_t(top->m_core->o_Address);
    instr = get_instruction(address);
    top->m_core->i_ReadData = instr;
    print_state(top, address);
    while(int(top->m_core->v__DOT__controller_0__DOT__fsm__DOT__state) != 0b0001) {
        top->tick();
        address = uint32_t(top->m_core->o_Address);
        instr = get_instruction(address);
        top->m_core->i_ReadData = instr;
        print_state(top, address);
    }
    top->testPort->o_Address = address;
    count++;
    assert(RegTable[3] == MEMORY[0x12]);
    return "assert_MEM_0x12_loaded_into_REG_0x3";
}

string assert_0x3_ORed_0x5_is_0x7_in_REG_0x4(Testbench * top, uint32_t * RegTable) {
    // 0x00e22025, // 0x03   RTYPE   0x7    0x2    0x4           OR
    uint32_t address = uint32_t(top->m_core->o_Address);
    uint32_t instr = get_instruction(address);
    top->m_core->i_ReadData = instr;
    print_state(top, address);
    top->tick();
    address = uint32_t(top->m_core->o_Address);
    instr = get_instruction(address);
    top->m_core->i_ReadData = instr;
    print_state(top, address);
    while(int(top->m_core->v__DOT__controller_0__DOT__fsm__DOT__state) != 0b0001) {
        top->tick();
        address = uint32_t(top->m_core->o_Address);
        instr = get_instruction(address);
        top->m_core->i_ReadData = instr;
        print_state(top, address);
    }
    top->testPort->o_Address = address;
    count++;
    assert(RegTable[0x4] == 0x7);
    return "assert_0x3_ORed_0x5_is_0x7_in_REG_0x4";
}

int main(int argc, char **argv, char **env) {
    Verilated::commandArgs(argc, argv);
    Testbench *top = new Testbench(true);
    // Open the trace file for waveform vcd
    top->opentrace("trace/trace.vcd");
    // quiet = true;
    int loop_count = 0;
    print("Testbench Version", top->version);
    print("Port Version", top->testPort->version);
    print("\nModule", "Processor", "Running Tests");
    auto * RegTable =  top->m_core->v__DOT__datapath_0__DOT__registers__DOT__RegTable;
    // uint32_t address = uint32_t(top->m_core->o_Address);

    // Also I added a S_RESET state to the FSM before I figured out I was not assigning
    // the insctruction to m_core. It appears to operate the same, but I need to be aware
    // of wierd behavior from reset wierdness
    top->reset();
    // First problem: I was reading the unstable input from memory (i_Memdata)
    // This caused the incorrect value to be loaded
    // Solution: Add a flip flop to the input to syncronize with design
    // top->run_tests(assert_MEM_0x11_loaded_into_REG_0x2(top, RegTable), count);
    //
    // Second problem: I was not changing the address vaiable in the test bench
    // Between tests. This caused instruction at address 0 to be loaded incorrectly
    // top->run_tests(assert_MEM_0x10_loaded_into_REG_0x7(top, RegTable), count);
    // top->run_tests(assert_MEM_0x12_loaded_into_REG_0x3(top, RegTable), count);
    // top->run_tests(assert_0x3_ORed_0x5_is_0x7_in_REG_0x4(top, RegTable), count);

    // NOTE: LB instruction originally adds imm and rb to get the memory address
    // My system doesn't really need this ability so I need to change the instructions
    // that use Imm


    uint32_t address = uint32_t(top->m_core->o_Address);
    uint32_t instr = get_instruction(address);
    top->m_core->i_ReadData = instr;
    while (loop_count < 64) {
        if(address != uint32_t(top->m_core->o_Address)) {
            address = uint32_t(top->m_core->o_Address);
            instr = get_instruction(address);
            top->m_core->i_ReadData = instr;
            // Need this to simulat memory writes
            if(top->m_core->o_memwrite)
                MEMORY[address] = top->m_core->o_WriteData;
        }
        top->tick();
        loop_count++;
    }
    // Instructions are currently being loaded into registers
    cout<<"MEMORY: "<<hex<<MEMORY[0x13]<<endl;
    assert(MEMORY[0x13] == RegTable[7]);
    assert(RegTable[7] == 0x07);
    delete top;
    exit(0);
}
